(* ::Package:: *)

(* ::Text:: *)
(*%%%%%%%%%%%%%%%%%%%%%%*)
(*			MIT License*)
(*%%%%%%%%%%%%%%%%%%%%%%*)
(**)
(*Copyright \[Copyright] 2025 Miguel Correia, Mathieu Giroux, and Sebastian Mizera. All rights reserved.*)
(**)
(*Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.*)
(**)
(*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*)


BeginPackage["SOFIA`"]
(*Documentation:*)
active::usage = "A list of active (integration) variables.";
\[Alpha]::usage = "The standard Schwinger parameter.";
Applyd::usage = "Expands the exterior derivative d[...] in the specified variables.";
BrownPanzer::usage = "Eliminates given variables in a set of polynomials. Available for solving non-Feynman systems.";
ContractionsNontrivial::usage = "Generates non-trivial subtopologies.";
d::usage = "The exterior derivative.";
dim::usage = "The space-time dimension.";
FastFubini::usage = "Eliminates given variables in a set of polynomials. Available for solving non-Feynman systems.";
Fubini::usage = " ";
RunningFubini::usage = " ";
FeynmanDraw::usage = "Opens a drawing window where you can sketch a diagram with your mouse. The output is the corresponding list of edges and nodes.";
FeynmanPlot::usage = "Draws the input diagram.";
finalEdgeMom::usage = "A list of edge momenta chosen by SOFIABaikov, minimizing the number of integration variables.";
FixLoopEdges::usage = "Finds an 'optimal' labeling of loop momenta.";
GenerateKinematics::usage = "Generates n-point kinematics.";
gramList::usage = "A list of determinants of matrices.";
HistoryGraph::usage = "Displays the history of parent and child subtopologies.";
homogeneizeKin::usage = "Homogenizes kinematics.";
IdentifyTheLoops::usage = "Finds edges contributing to each loop, treating them as simple cycles.";
integrand::usage = "The loop-by-loop integrand output of SOFIABaikov.";
LBL::usage = "Generates the Baikov matrices from a diagram input. The base function of SOFIABaikov.";
l::usage = "A label for loop momenta.";
LocalityConditions::usage = "For a given diagram, returns the loop momenta in terms of the Schwinger parameters \[Alpha].";
M::usage = "The external mass scale.";
matrices::usage = "The Baikov matrices/Gram determinants: external (odd positions) and internal (even positions) Gram matrices.";
matricesPairs::usage = "A list of pairs of Baikov matrices.";
m::usage = "The internal mass scale.";
MM::usage = "The squared external mass scale.";
mm::usage = "The squared internal mass scale.";
MyFactorList::usage = "Factors a list of polynomials into a list of irreducible components.";
MyPropagators::usage = "A list of propagators chosen by SOFIABaikov.";
MySubstitutions::usage = "A list of substitutions generated by SOFIABaikov.";
mzFLAG::usage = "A dummy variable.";
NLoops::usage = "Computes the number of loops in a diagram.";
NumberOfCriticalPoints::usage = "Counts the number of critical points/master integrals from the Baikov representation.";
\[Nu]::usage = "An integer parameter.";
p::usage = "A label for external momenta.";
prefactor::usage = "The constant prefactor of the loop-by-loop integrand output of SOFIABaikov.";
ProportionalPolynomialsQ::usage = "Checks whether two polynomials are equal up to an overall constant.";
q::usage = "A dummy label for edge loop momenta.";
r::usage = "A letter used by Effortless to denote a root.";
s::usage = "A label for Mandelstam variables.";
shift::usage = "The shifted loop momenta.";
SingOnly::usage = "A dummy variable.";
SOFIA::usage = "Returns the singularities or letters depending on options.";
SOFIABaikov::usage = "Returns the optimized LBL Baikov representation for an input diagram (list of edges and nodes).";
SOFIADecomposeAlphabet::usage = "SOFIADecomposeAlphabet[LetterToDecompose,SymbolData] - decomposes the letter LetterToDecompose in terms of the alphabet provided in SymbolData.";
SOFIASingularities::usage = "Returns a list of singularities for an input Feynman graph."; 
SolvePolynomialSystem::usage = "Solves a polynomial system using the method specified by the Solver->{FastFubini, momentumPLD} option.";
Subtopologies::usage = "Generates non-trivial subtopologies.";
SubtopologiesR::usage = "Generates non-trivial subtopologies using reflexion symmetries.";
Symmetry::usage = "Finds, if it exists, the symmetry between two graphs.";
SymmetryQuotient::usage = "Given a list of diagrams, returns a reduced list of diagrams with a symmetry map.";
TakeMaxCut::usage = "Evaluates the LBL Baikov integrand on the maximal cut.";
takeMaxCut::usage = "Variables to set to zero to localize on the maximal cut.";
t::usage = "A label for Mandelstam variables.";
timed::usage = "A function for real-time timing.";
TrySolveStandardLandau::usage = "Attempts to solve standard Landau equations. Not optimized for complicated examples.";
w::usage = "A letter used by Effortless to denote a rational logarithmic entry.";
W::usage = "A letter used by Effortless to denote a rational logarithmic entry.";
wedge1::usage = "The first rule to deal with wedge products.";
wedge2::usage = "The second rule to deal with wedge products.";
xsExpanded::usage = "A list of the Baikov variables used by SOFIABaikov[].";
\[Delta]::usage = "An expansion parameter.";
generatedSubtopologies::usage = " ";

(*Initiate package:*)
Begin["`Private`"]
Print["Singularities of Feynman Integrals Automatized (v1.0.0.)"];
Print[
  Style["
 .oooooo..o   .oooooo.   oooooooooooo ooooo       .o.       
d8P'    `Y8  d8P'  `Y8b  `888'     `8 `888'      .888.      
Y88bo.      888      888  888          888      .8\"888.     
 `\"Y8888o.  888      888  888oooo8     888     .8' `888.    
     `\"Y88b 888      888  888    \"     888    .88ooo8888.   
oo     .d8P `88b    d88'  888          888   .8'     `888.  
8\"\"88888P'   `Y8bood8P'  o888o        o888o o88o     o8888o|
", 
    RGBColor[0.5, 0, 0]
  ]
];

<<"GraphUtilities`";

(*Lorentz rules and exterior algebra:*)
Clear[Wedge,d,CenterDot];
SetAttributes[CenterDot,Orderless];
CenterDot/:CenterDot[x_+y_,z_]:=CenterDot[x,z]+CenterDot[y,z];
CenterDot/:CenterDot[c_*x_,y_]:=c CenterDot[x,y]/;NumericQ[c];
CenterDot/:CenterDot[0,y_]:=0;
Protect[CenterDot];
wedgerules[arg_]:=arg//.wedge1//.wedge2;
wedge1={
Wedge[u___,x_+y_,z___]:>Wedge[u,x,z]+Wedge[u,y,z],
Wedge[x___, (scalar_ :1)Wedge[y__],z___]:> scalar Wedge[x,y,z],
Wedge[x___,scalar_ d[z_],y___]:>scalar Wedge[x,d[z],y],
Wedge[u___,x_,z___]:>x Wedge[u,z]/;FreeQ[x,d[_]],
Wedge[d[x_]]:>d[x]
};
wedge2={
Wedge[u___,x_,y_,z___]:>-Wedge[u,y,x,z]/;Not@OrderedQ[{x,y}],
Wedge[u___,x_,y___,x_,z___]:>0
};
d/:d[x_+y_]:=d[x]+d[y];
d/:d[x_ d[y_]]:=Wedge[d[x],d[y]];
d/:d[(x_:1) Wedge[y__]]:=Wedge[d[x],y];
d/:d[d[x__]]:=0;
Applyd[vars_]:={
d[x_]:>((Sum[D[x,vars[[i]]]d[vars[[i]]],{i,1,Length[vars]}]))
};
Applyd[exp_,vars_]:=exp//.Applyd[vars]//.wedge1//.wedge2;

(*n-point kinematic:*)
Clear[GenerateKinematics];
GenerateKinematics[nParticles_]:=
If[nParticles==2,{Subscript[p, 1]\[CenterDot]Subscript[p, 1]->s},Module[{out},
n=nParticles;
ppMatrix=Table[If[i==j,Subscript[M, i]^2,(Subscript[s, Sequence@@Sort[{i,j}]]-Subscript[M, i]^2-Subscript[M, j]^2)/2],{i,n},{j,n}];
cyclicBasis=Flatten[Table[Subscript[s, Sequence@@Sort[Mod[Range[a,a+l],n,1]]],{l,1,n/2-1},{a,If[l==n/2-1,n/2,n]}]];
sRelations=Flatten[Table[Subscript[s, Sequence@@Sort[Mod[Range[a,a+l],n,1]]]==Sum[ppMatrix[[b,c]],{b,Mod[Range[a,a+l],n,1]},{c,Mod[Range[a,a+l],n,1]}],{l,1,n/2-1},{a,If[l==n/2-1,n/2,n]}]];
momentumConservation=Table[Sum[ppMatrix[[i,j]],{j,n}]==0,{i,n}];
solution=Solve[
Join[momentumConservation,sRelations]
,Complement[Variables[ppMatrix],cyclicBasis,Table[Subscript[M, i],{i,n}]]][[1]];
substitutions=Flatten[Table[Subscript[p, i]\[CenterDot]Subscript[p, j]->ppMatrix[[i,j]]/.solution//Factor,{i,n},{j,n}]];
out=substitutions
]
];

(*Feynman diagrammatic:*)
FeynmanDraw:=Module[{edgelist,edgelist2,extnodes,posnodes,nodes0,edgelist3,vertices,ivertices,reordering,intmasses,allEdges,nodes1,edgelistfinal,edges,nodes,en},
edgelist=GraphUtilities`GraphEdit[][[2,2]];
edgelist2=Partition[ToExpression[StringReplace[ToString[edgelist],"->"-> ","]],2];
extnodes=Select[Tally[Flatten[edgelist2]],#[[2]]==1&]//Transpose//First;
posnodes=(Position[edgelist2,#][[1]]&/@extnodes)/.{{x_,1}->{x,2},{x_,2}->{x,1}};
nodes0=Sort[Table[Part[edgelist2,posnodes[[n,1]],posnodes[[n,2]]],{n,1,Length[extnodes]}]];
edgelist3=Sort/@Delete[edgelist2,List/@(posnodes//Transpose//First)];
vertices=edgelist3//Flatten//DeleteDuplicates;
ivertices=Complement[vertices,nodes0];
nodes1=nodes0//DeleteDuplicates;
reordering=Join[Table[nodes1[[i]]->i,{i,1,Length[nodes1]}],Table[ivertices[[i]]->i+Length[nodes1],{i,1,Length[ivertices]}]];
edgelistfinal=Sort/@(edgelist3/.reordering);
edges=Table[{edgelistfinal[[i]],Subscript[m, i](*^2*)},{i,1,Length[edgelistfinal]}];
nodes=Table[{Part[nodes0/.reordering,i],Subscript[M, i]},{i,1,Length[nodes0]}];
en={edges,nodes};
FeynmanPlot[en]//Echo;
Return[en];
];
ContractEdge[edgenode_,edgein_]:=Module[{edgect,edgelist,posedgect,newedges,newnodes,edges0,edges,nodes},
edges0=edgenode[[1]]; nodes=edgenode[[2]];
edges={Sort/@Transpose[edges0][[1]],Transpose[edges0][[2]]}//Transpose; (*sorts them correctly*);
edgelist=Sort/@edges[[All,1]];
If[Depth[edgein]==2,
edgect=Sort[edgein];posedgect=(Position[edgelist,edgect]//Flatten)[[1]];,
edgect={Sort[edgein[[1]]],edgein[[2]]};posedgect=(Position[edges,edgect]//Flatten)[[1]];];
newedges=Delete[edges,posedgect]//.{{x_,edgelist[[posedgect,2]]}->{x,edgelist[[posedgect,1]]},{edgelist[[posedgect,2]],x_}->{edgelist[[posedgect,1]],x}};
newnodes=nodes/.{{edgelist[[posedgect,2]],x_}->{edgelist[[posedgect,1]],x}};
{newedges,newnodes}];
ContractSingle[edgenode_]:=Table[ContractEdge[edgenode,edgenode[[1,j]]],{j,1,Length[edgenode[[1]]]}];
Contractions[edgenode_]:=Module[{contractions,j,max,inter1,inter2},
max=Length[edgenode[[1]]];
For[j=0;contractions[0]={edgenode},j<=max,j++,
inter1=Table[ContractSingle[contractions[j][[i]]],{i,1,contractions[j]//Length}]//Flatten[#,1]&;
inter2=Select[DeleteTadpoles/@inter1,OneVertexIrreducibleQ[#]&&NotContactQ[#]&];
contractions[j+1]=inter2];
Table[contractions[j],{j,0,max}]//Flatten[#,1]&//DeleteDuplicates
];

(*History tree:*)
Clear[ContractionTreeFeynman,ContractionTreeEN,trimList,extractKeys]
edgenodeQ[{child_List, _}] := True;edgenodeQ[_] := False;
ContractionTreeCombined[transform_, {x_, {}}] :=
  ContractionTreeCombined[transform, {x, {}}] = {transform[{x, {}}], {}};
ContractionTreeCombined[transform_, edgenode_?edgenodeQ] /; Length[edgenode[[1]]] > 0 :=
  ContractionTreeCombined[transform, edgenode] = Module[{children},
    children = Map[ContractionTreeCombined[transform, #] &, ContractSingle[edgenode]];
    {transform[edgenode], children}
  ];
ContractionTreeCombined[transform_, edgenode_] :=
  ContractionTreeCombined[transform, edgenode] = {transform[edgenode], {}};
ContractionTreeFeynman[edgenode_] := ContractionTreeCombined[FeynmanPlot, edgenode];
ContractionTreeEN[edgenode_] := ContractionTreeCombined[Identity, edgenode];
Clear[trimList,extractKeys,extractKeysHelper]
trimList[{x_, {}}] := {{x}};
trimList[{x_, children_List}] := Module[{paths},
  paths = Join @@ (trimList /@ children);
  Prepend[#, x] & /@ paths
];
extractKeys[node_] := Module[{keys},
  keys = Reap[extractKeysHelper[node]][[2, 1]];
  keys
];
extractKeysHelper[{x_, children_List}] := (Sow[x]; Scan[extractKeysHelper, children]);
extractKeysHelper[_] := Null;
HistoryGraph[diag_] := HistoryGraph[diag] =
 Module[{ten, tfey, trimmedTfey, keyMap, processedSubLists, tpRule,valid,tadpoles},
  ten = ContractionTreeEN[diag];
  tfey = ContractionTreeFeynman[diag];
  keyMap = Thread[extractKeys[tfey] -> extractKeys[ten]];
    trimmedTfey =DeleteDuplicates[Flatten[Thread[Most[#1]->Rest[#1]]&[#]&/@DeleteDuplicates[trimList[tfey]]]]/.Rule[A_,B_]:>{A,B}/. keyMap;
  deb00=trimmedTfey;
  processedSubLists =
  Map[
    FeynmanPlot /@ 
       Select[DeleteTadpoles /@ #, 
       OneVertexIrreducibleQ[#] && NotContactQ[#] &] &,
    trimmedTfey
    ];
  processedSubLists = DeleteDuplicates[processedSubLists];
  tpRule = Flatten[Rule @@@ Partition[#, 2, 1] & /@ processedSubLists,1];
  tpRule = Select[DeleteDuplicates[tpRule], #[[1]] =!= #[[2]] &];
  If[SameQ[tpRule,{}],Return[FeynmanPlot[diag]],
  Return[TreePlot[tpRule, VertexLabels -> Placed[Automatic, Center],
   VertexSize -> .02, PlotTheme -> "Monochrome",
   PlotRangePadding -> Scaled[0.2]]]
   ];
  ];

NLoops[edgesnodes_]:=(1+Length[edgesnodes[[1]]]-Length[Join[edgesnodes[[1]][[All,1]],edgesnodes[[1]][[All,1]]]//Flatten//DeleteDuplicates//Sort]);
NVertexCut[edgenode_]:= Module[{edges},
edges=Transpose[edgenode[[1]]][[1]]//Quiet;
If[SameQ[edges,{}[[1]]]//Quiet,0,
edgelist=#[[1]]\[UndirectedEdge]#[[2]]&/@edges;
FindVertexCut[edgelist]//Length]];
OneVertexIrreducibleQ[edgenode_]:=Module[{edgelist,edges,NVertexCut},
edges=Transpose[edgenode[[1]]][[1]]//Quiet;
NVertexCut=If[SameQ[edges,{}[[1]]]//Quiet,0, edgelist=#[[1]]\[UndirectedEdge]#[[2]]&/@edges;FindVertexCut[edgelist]//Length];
If[NVertexCut>1,True,If[VertexCount[edgelist]>2,False,If[Length[DeleteDuplicates[Transpose[edgenode[[2]]][[1]]]]===1,False,True]]]];

(*SetAttributes[ReflectionQ,Orderless];*)
ReflectionQ[d1_,d2_]:=Module[{sym},sym=Symmetry[d1,d2]; If[SameQ[Length[sym],2],If[SameQ[sym[[2]],{}],True,False],False]];

NoTadpoleQ[edgenode_]:=If[SameQ[Select[edgenode[[1]],SameQ[#[[1,1]],#[[1,2]]]&],{}],True,False];
NotContactQ[edgenode_]:=If[SameQ[edgenode[[1]],{}],False,True];
DeleteTadpoles[edgenode_]:=Module[{edges},edges=edgenode[[1]];{Select[edges,UnsameQ[#[[1,1]],#[[1,2]]]&],edgenode[[2]]} ];
ContractionsNontrivial[edgenode_]:=ContractionsNontrivial[edgenode]=Select[DeleteTadpoles/@Contractions[edgenode],OneVertexIrreducibleQ[#]&&NotContactQ[#]&];

(*Subtopologies functions with reflection:*)
ContractionsR[edgenode_]:=Module[{contractions,j,max,inter1,inter2,inter3,out},
max=Length[edgenode[[1]]];
For[j=0;out=0;contractions[0]={edgenode},j<max&&out==0,j++,
inter1=Table[ContractSingle[contractions[j][[i]]],{i,1,contractions[j]//Length}]//Flatten[#,1]&;
inter2=Select[DeleteTadpoles/@inter1,OneVertexIrreducibleQ[#]&&NotContactQ[#]&];
If[SameQ[inter2,{}],out=1,
inter3=Transpose[Tally[inter2,ReflectionQ]][[1]];
	contractions[j+1]=inter3]];
Table[contractions[a],{a,0,j-out}]//Flatten[#,1]&//DeleteDuplicates
];

Subtopologies[edgenode_,Reflections_:False]:=Subtopologies[edgenode,Reflections]=Monitor[
If[SameQ[Reflections,False],
DeleteDuplicates[{{SortBy[#[[1]],Length],#[[-1]]}&/@(#[[1]]),#[[-1]]}&/@Contractions[edgenode]],
DeleteDuplicates[{{SortBy[#[[1]],Length],#[[-1]]}&/@(#[[1]]),#[[-1]]}&/@ContractionsR[edgenode]]
]
,"Constructing subtopologies..."];

(*Diagram display:*)
FeynmanPlot[x_]:=FeynmanPlot[x[[1]],x[[2]]];
FeynmanPlot[edgesin_,nodesin_]:=Module[{},
ContactQ=SameQ[edgesin,{}];(*True if it's a contact diagram*);
If[ContactQ, {edges={},nodes=nodesin},(*checks the trivial case of contact diagrams*)
If[Length[Part[Flatten/@edgesin,1]]==3,{edges=edgesin,nodes=nodesin}, {nodes=edgesin,edges=nodesin}](*corrects arguments if they were swapped by mistake*);];
edgelist=Sort/@(#[[1]]&/@edges);
vertices=If[ContactQ,{1},Sort[DeleteDuplicates[Flatten[edgelist]]]];
intmasses=#[[2]]&/@edges;
extmasses=#[[2]]&/@nodes;
vmax=vertices[[-1]];
masslesspos=Position[Join[intmasses,extmasses],0]//Flatten;
vmasslesspos=(Position[extmasses,0]//Flatten)+vmax;
allEdges=Join[#[[1]]\[UndirectedEdge]#[[2]]&/@edgelist,#[[1]]\[DirectedEdge]#[[2]]&/@Table[{vmax+v,nodes[[v,1]]},{v,Length[nodes]}]];
multiplicity=Sort[Transpose[Tally[allEdges]][[2]]][[-1]];
graph0=EdgeTaggedGraph[Join[vertices,Range[vmax+1,vmax+Length[nodes]]],allEdges];
edgelistgraph=EdgeList[graph0];
masslessedges=Part[edgelistgraph,masslesspos];
massiveInternalEdges=DeleteCases[edgelistgraph,Alternatives@@Join[masslessedges,edgelistgraph[[-Length[nodes];; -1]]]];
graph = EdgeTaggedGraph[
   Join[vertices, Style[#, Transparent] & /@ Range[vmax + 1, vmax + Length[nodes]]],
   allEdges,
   EdgeWeight -> Thread[edgelistgraph -> (Style[#, Black, Background -> White] & /@ Join[intmasses, extmasses])],
   VertexWeight -> Join[vertices, Subscript[p, #] & /@ Range[Length[nodes]]]
];
GraphPlot[
  graph,
  EdgeLabels -> Thread[Complement[edgelistgraph, masslessedges] -> "EdgeWeight"],
  VertexLabels -> Thread[VertexList[graph0] -> "VertexWeight"],
  MultiedgeStyle -> 0.22*(multiplicity - 1),
  PlotTheme -> "Scientific",
  PlotRangePadding -> Scaled[0.2],
  GraphLayout -> "SpringElectricalEmbedding",
  EdgeStyle -> Merge[
    {
      Thread[masslessedges -> Directive[Dashed, Thick]],
      Thread[massiveInternalEdges -> Directive[Thick]],
      Thread[edgelistgraph[[-Length[nodes];; -1]] -> Directive[Thick, Arrowheads[{{Medium, 0.23}}]]]
    },
    If[Length[#] > 1, Directive @@ #, First[#]] &
  ] // Normal
]
];
FeynmanPlot[edgesin_,nodesin_,edgelabels_,edgespecial_]:=Module[{},
ContactQ=SameQ[edgesin,{}];(*True if it's a contact diagram*);
If[ContactQ, {edges={},nodes=nodesin},(*checks the trivial case of contact diagrams*)
If[Length[Part[Flatten/@edgesin,1]]==3,{edges=edgesin,nodes=nodesin}, {nodes=edgesin,edges=nodesin}](*corrects arguments if they were swapped by mistake*);];
edgelist=Sort/@(#[[1]]&/@edges);
vertices=If[ContactQ,{1},Sort[DeleteDuplicates[Flatten[edgelist]]]];
intmasses=#[[2]]&/@edges;
extmasses=#[[2]]&/@nodes;
vmax=vertices[[-1]];
masslesspos=Position[Join[intmasses,extmasses],0]//Flatten;
vmasslesspos=(Position[extmasses,0]//Flatten)+vmax;
allEdges=Join[#[[1]]\[UndirectedEdge]#[[2]]&/@edgelist,#[[1]]\[DirectedEdge]#[[2]]&/@Table[{vmax+v,nodes[[v,1]]},{v,Length[nodes]}]];
multiplicity=Sort[Transpose[Tally[allEdges]][[2]]][[-1]];
graph0=EdgeTaggedGraph[Join[vertices,Range[vmax+1,vmax+Length[nodes]]],allEdges];
edgelistgraph=EdgeList[graph0];
masslessedges=Part[edgelistgraph,masslesspos];
massiveInternalEdges=DeleteCases[edgelistgraph,Alternatives@@Join[masslessedges,edgelistgraph[[-Length[nodes];; -1]]]];
graph=EdgeTaggedGraph[Join[vertices,Style[#,Transparent]&/@Range[vmax+1,vmax+Length[nodes]]],allEdges,EdgeWeight->Thread[edgelistgraph->(Style[#,Black,Background->White]&/@Join[edgelabels,Table[0,nodes//Length]])],VertexWeight->Join[vertices,Subscript[p, #]&/@Range[nodes//Length]]];
GraphPlot[graph,
  EdgeLabels -> Thread[Complement[edgelistgraph, edgelistgraph[[-Length[nodes];;-1]]] -> "EdgeWeight"],
  VertexLabels -> Thread[VertexList[graph0] -> "VertexWeight"],
  MultiedgeStyle -> 0.22*(multiplicity - 1),
  PlotTheme -> "Scientific",
  PlotRangePadding -> Scaled[0.2],
  GraphLayout -> "SpringElectricalEmbedding",
  EdgeStyle -> Merge[
    {
      Thread[masslessedges -> Directive[Dashed, Thick]],
      Thread[massiveInternalEdges -> Directive[Thick]],
      Thread[edgelistgraph[[-Length[nodes];; -1]] -> Directive[Thick, Arrowheads[{{Medium, 0.23}}]]],
      Thread[Part[edgelistgraph, #] & /@ edgespecial -> Directive[Black, Thick]]
    },
    If[Length[#] > 1, Directive @@ #, First[#]] &
  ] // Normal
]
];

(*FastFubini and helper functions:*)
MyFactorList[list_]:=Select[DeleteDuplicates[Flatten[Map[FactorList[#][[All,1]]&,list]]],!NumericQ[#]&];
myPolynomialDecomposition[P_,vars_List]:=Module[{cr,monomials,coeffs},
cr=CoefficientRules[P,vars];
monomials=Map[Apply[Times,MapThread[#1^#2&,{vars,#}]]&,First/@cr];
coeffs=Last/@cr;
{coeffs,monomials}];
generateAnsatzDISPATCH[gramList_,active_,dummyVAR_]:=Module[{},
Clear[ansatz0,fixCoeffs];
ansatz0=Table[#[[ii]] . Array[dummyVAR[ii],Length[#[[ii]]]],{ii,Length[#]}]&[myPolynomialDecomposition[#,active][[2]]&/@gramList];
fixCoeffs=Dispatch[Flatten[Table[Thread[Array[dummyVAR[ii],Length[#[[ii]]]]->#[[ii]]],{ii,Length[#]}]&[myPolynomialDecomposition[#,active][[1]]&/@gramList]]];
Return[{ansatz0,fixCoeffs}];
];
discriminant[poly_,var_,p_:0,dummyVAR_]:=Module[{out,tempf},
tempf=QuietEcho[generateAnsatzDISPATCH[{#1},{var},dummyVAR]]&[poly];
out=Discriminant[tempf[[1]][[1]],var,Method->"Subresultants",Modulus->p]/.tempf[[2]];
Return[out];
];
resultant[poly1_,poly2_,var_,p_:0,dummyVARLIST_List]:=Module[{out,tempf1,tempf2},
tempf1=QuietEcho[generateAnsatzDISPATCH[{#1},{var},dummyVARLIST[[1]]]]&[poly1];
tempf2=QuietEcho[generateAnsatzDISPATCH[{#1},{var},dummyVARLIST[[2]]]]&[poly2];
out=Resultant[tempf1[[1]][[1]],tempf2[[1]][[1]],var,Method->"Subresultants",Modulus->p]/.tempf1[[2]]/.tempf2[[2]];
Return[out];
];
ProportionalPolynomialsQ[poly1_, poly2_, checks_ : 5, p_ : 0] := 
  Module[{vars, i},
   If[Length[poly1] != Length[poly2], Return[False]];
   vars = Variables[poly1];
   If[Variables[poly2] =!= vars, Return[False]];
   Return[CountDistinct[Table[
       ((If[p > 0, Mod[#, p], #] & /@ (poly1^2 + 1))/
            (If[p > 0, Mod[#, p], #] & /@ (poly2^2 + 
            1))) /. ((# -> RandomInteger[{1, 10^2}]) & /@ vars)
       , {i, checks}]] == 1];
   ];
   
   
FastFubini[polynomials_List,variables_List,limit_Integer:100,p_Integer:0,FactorLast_:True]:=FastFubini[polynomials,variables,limit,p,FactorLast]=Module[{set,freePolynomials,preSTable,preS,size,vars},
set[{}]=polynomials;
freePolynomials={};
Do[
preSTable=Table[Fubini[set[Sort[Complement[vars,{v}]]],{v},limit,p,FactorLast],{v,vars}];
preS=Apply[Intersection[##,SameTest->(ProportionalPolynomialsQ[#1,#2,3,p]&)]&,preSTable];
set[Sort[vars]]=Table[
If[Intersection[variables,Variables[f]]==={},
freePolynomials=Append[freePolynomials,f];Nothing,f]
,{f,preS}];
,{size,Length[variables]},{vars,Subsets[variables,{size}]}]
;
Return[DeleteDuplicates[Join[set[Sort[variables]],freePolynomials],ProportionalPolynomialsQ[#1,#2,3,p]&]];
];

Fubini[polynomials_List,variables_List,limit_Integer:100,p_Integer:0,FactorLast_:True]:=Fubini[polynomials,variables,limit,p,FactorLast]=Module[{Snew,degrees,terms,term1,term2,var,f},
Snew=polynomials;
Monitor[
Do[
degrees=Table[Length[CoefficientList[ss,var]]-1,{ss,Snew}];
terms=Table[Length[ss],{ss,Snew}];
term1=Flatten[Table[
{CoefficientList[f,var][[-1]],
If[FreeQ[f,var],Nothing,If[Length[f]>limit,Nothing,discriminant[f,var,p,cc0]]]}
,{f,Snew}]];
term2=Flatten[Table[If[FreeQ[Snew[[ii]],var]||FreeQ[Snew[[jj]],var]||Length[Snew[[ii]]]>limit||Length[Snew[[jj]]]>limit,Nothing,
resultant[Snew[[ii]],Snew[[jj]],var,p,{cc1,cc2}]]
,{ii,Length[Snew]},{jj,ii+1,Length[Snew]}]];
Snew=
If[SameQ[FactorLast,False],
If[SameQ[var,variables[[-1]]],
Select[
Join[term1,term2]
,Not[NumericQ[#]]&],
Select[
DeleteDuplicates[Flatten[Map[FactorList[#,Modulus->p][[All,1]]&,Join[term1,term2]]]]
,Not[NumericQ[#]]&]
],
Select[
DeleteDuplicates[Flatten[Map[FactorList[#,Modulus->p][[All,1]]&,Join[term1,term2]]],ProportionalPolynomialsQ[#1,#2,10,p]&]
,Not[NumericQ[#]]&]
];
,{var,variables}]
,
Row[{
"Variable currently being eliminated: ", var, 
       "  |  Polynomial degrees: ", degrees, 
       "  |  Polynomial lengths: ", terms}]
]
;
Return[Snew];
];
RunningFubini[S_,vars2_,limit_:8,p_:0,FactorLast_:True]:=Module[{permutations,runningResult,current,perm},
permutations=RandomSample[Permutations[vars2]];
runningResult=Nothing;
Monitor[Do[
Echo[perm,"Checking ordering"];
current=FastFubini[S,perm,limit,p,FactorLast];
runningResult=If[runningResult===Nothing,
current,
Intersection[runningResult,current,SameTest->(ProportionalPolynomialsQ[#1,#2,10,p]&)]];
,{perm,permutations}],runningResult];
Return[runningResult];
];

(*FixingLoopEdges and helper functions:*)
normalizeEdge[UndirectedEdge[a_,b_,w_]]:=UndirectedEdge[Min[a,b],Max[a,b],w];
FirstUniqueOnePositions[matrix_]:=Module[{trimmed,zeroCols,positions},
trimmed=matrix[[All,1;;-2]];
zeroCols=Position[Total[trimmed,{1}],1][[All,1]];
positions=Table[SelectFirst[Range[Length[trimmed[[i]]]],MemberQ[zeroCols,#]&&trimmed[[i,#]]==1&],{i,Length[trimmed]}];
positions];
CycleToIndicator[cycle_,edgelist_]:=Boole[MemberQ[cycle,#]&/@edgelist];
addedges[edges_]:=Cases[Tally[Flatten[edges],Sort[#1]===Sort[#2]&],{e_,_?OddQ}:>e];
FixLoopEdges[edgesnodes_]:=QuietEcho[Module[{NOLOOPS,tempCycleMatrices,inCycleMatrix,edgesin,nodesin,pos,cycles0,(*cycles1, cycles2, cycles3,*)cycles(*,OUT*),edges,nodes,edgelist,vertices,intmasses,extmasses,vmax,masslessedges,masslesspos,vmasslesspos,allEdges,multiplicity,graph0,edgelistgraph,graph,ContactQ},
NOLOOPS=(1+Length[edgesnodes[[1]]]-Length[Join[edgesnodes[[1]][[All,1]],edgesnodes[[1]][[All,1]]]//Flatten//DeleteDuplicates//Sort]);
edgesin=edgesnodes[[1]];
nodesin=edgesnodes[[-1]];
ContactQ=SameQ[edgesin,{}];
If[ContactQ, {edges={},nodes=nodesin},
If[Length[Part[Flatten/@edgesin,1]]==3,{edges=edgesin,nodes=nodesin}, {nodes=edgesin,edges=nodesin}];];
edgelist=Sort/@(#[[1]]&/@edges);
vertices=If[ContactQ,{1},Sort[DeleteDuplicates[Flatten[edgelist]]]];
intmasses=PowerExpand[Sqrt[#[[2]]]]&/@edges;
extmasses=#[[2]]&/@nodes;
vmax=vertices[[-1]];
masslesspos=Position[Join[intmasses,extmasses],0]//Flatten;
vmasslesspos=(Position[extmasses,0]//Flatten)+vmax;
allEdges=#[[1]]\[UndirectedEdge]#[[2]]&/@Join[edgelist,Table[{nodes[[v,1]],vmax+v},{v,Length[nodes]}]];
multiplicity=Sort[Transpose[Tally[allEdges]][[2]]][[-1]];
graph0=EdgeTaggedGraph[Join[vertices,Range[vmax+1,vmax+Length[nodes]]],allEdges];
edgelistgraph=EdgeList[graph0]//Echo;
edgelistgraph=normalizeEdge/@edgelistgraph;
tempCycleMatrices=Select[
{CycleToIndicator[#,edgelistgraph]&/@Table[normalizeEdge/@#1[[ii]],{ii,Length[#1]}]&[FindFundamentalCycles[edgelistgraph]],CycleToIndicator[#,edgelistgraph]&/@Table[normalizeEdge/@#1[[ii]],{ii,Length[#1]}]&[Pick[EdgeList[edgelistgraph],#,1] & /@Normal[EdgeCycleMatrix[edgelistgraph]]]}
,Length[#]==NOLOOPS&];
inCycleMatrix=SortBy[MinimalBy[Join[tempCycleMatrices,ConstantArray[1000, {NOLOOPS,NOLOOPS}]],Total[Flatten[#]]&],Length][[1]];
pos=FirstUniqueOnePositions[
First[
MinimalBy[{
SortBy[Map[Append[#,Total[#]]&,RowReduce[inCycleMatrix,Modulus->2]
],Last],
SortBy[Map[Append[#,Total[#]]&,inCycleMatrix],Last]
},Total[#[[All,-1]]]&]
]
];
Return[pos];
]];

(*Extra helper functions:*)
SetAttributes[timed,HoldAll];
timed[expr_]:=With[{start=AbsoluteTime[]},PrintTemporary@Dynamic[Row[{"Time elapsed: ",AbsoluteTime[]-start}],UpdateInterval->0.1];
expr];
ClearAll[listMinors];
listMinors[M_]:=Module[{n=Dimensions[M][[1]],combs,minorsOfSize,allMinors,extractSubmatrix},
combs[list_,size_]:=Subsets[list,{size}];
extractSubmatrix[rows_,cols_]:=M[[rows,cols]];
minorsOfSize[size_]:=Module[{rowCombs,colCombs,subMs},rowCombs=combs[Range[n],size];
colCombs=combs[Range[Dimensions[M][[2]]],size];
toPrint=Flatten[Table[MatrixForm[extractSubmatrix[rowCombs[[i]],colCombs[[j]]]],{i,Length[rowCombs]},{j,Length[colCombs]}],1];
Echo[toPrint];
subMs=Flatten[Table[Det[extractSubmatrix[rowCombs[[i]],colCombs[[j]]]],{i,Length[rowCombs]},{j,Length[colCombs]}],1];
subMs];
allMinors=Table[minorsOfSize[size],{size,1,Min[n,Dimensions[M][[2]]]}];
allMinors];
ExciseRowsColumns[matrix_,rowsToDelete_,colsToDelete_]:=Module[{rows,cols},rows=Delete[matrix,List/@rowsToDelete];
cols=Transpose[Delete[Transpose[rows],List/@colsToDelete]];
cols];
extractAis[expr_]:=DeleteDuplicates[Cases[expr,Subscript[a,_],{0,Infinity}]];
filteredList[list_]:=Module[{seenAis={}},Select[list,Function[entry,With[{aTerms=extractAis[entry[[2]]]},If[DisjointQ[seenAis,aTerms],AppendTo[seenAis,#]&/@aTerms;True,False]]]]];
nlbl[loop_,listE_]:=loop+(Plus@@listE);
homogeneizeKin[arg_]:=arg//.Subscript[s, a___]:>ToExpression["s"<>StringJoin[ToString/@{a}]]//.Subscript[M, i_]:>Sqrt[ToExpression["MM"<>ToString[i]]]//.Subscript[m, i_]:>Sqrt[ToExpression["mm"<>ToString[i]]]//.M:>Sqrt[MM]//.m:>Sqrt[mm];

(*SOFIABaikov:*)
rankDropRule[OUT_]:=Module[{},
temp1=#[[1]]&/@OUT;
numTemp=Thread[#->(#1[[1]]/#1[[-1]]&/@RandomChoice[Subsets[DeleteDuplicates[RandomPrime[{5,10000},1000]],{2}],Length[#]])]&[Variables[temp1]];
temp2=NullSpace/@(temp1//.numTemp);
temp3=Table[If[SameQ[temp2[[ii]],{}],
{},
Subsets[#[[1]],{#[[-1]]}]&[{DeleteDuplicates[Flatten[#]],Length[#]}&[
SparseArray[#]["NonzeroPositions"]&/@temp2[[ii]]]]
]
,{ii,Length[temp2]}];
temp4=If[Length[#1]>0,First[Flatten[SparseArray[#1]["NonzeroPositions"]]],NONE]&/@Table[
Factor[Det[ExciseRowsColumns[(temp1//.numTemp)[[ii]],temp3[[ii]][[jj]],temp3[[ii]][[jj]]]]]
,{ii,Length[temp3]},{jj,Length[temp3[[ii]]]}];
temp5=Table[
If[
SameQ[temp4[[ii]],NONE],
Echo["NO rank drop detected for matrix: "<>ToString[ii]<>""];temp1[[ii]],
Echo["Rank drop detected for matrix: "<>ToString[ii]<>""];ExciseRowsColumns[temp1[[ii]],temp3[[ii]][[temp4[[ii]]]],temp3[[ii]][[temp4[[ii]]]]]
]
,{ii,Length[temp4]}];
If[ContainsAny[Simplify[Det/@(temp5//.numTemp)],{0}],Echo[Style["Something is wrong: some matrices still not have full rank. You should probably reconsider the input of loop edges.",Red]],Echo[Style["All matrices have full rank!",Blue]]];
Return[MatrixForm/@temp5];
];
FindLoopMomShift[AllEliminate\[CapitalLambda]_]:=Module[{},
seed=Select[AllEliminate\[CapitalLambda]/.Subscript[l, i_]:>Subscript[l, i]+Subscript[a, i],!FreeQ[#,Subscript[l, _]]&];
tab=DeleteCases[Table[#[[1]]&/@Position[seed,Subscript[a, ii]],{ii,noLoops}],{}];
pos[0]=tab[[1]];
Do[
pos[ii]=DeleteCases[tab[[ii]],Alternatives@@Flatten[Table[tab[[jj-1]],{jj,ii}]]],
{ii,Length[tab]}];
foo1=seed[[Flatten[Table[pos[ii],{ii,Length[tab]}]]]]//.Rule[a_,b_]:>b;
foo2=(#[[1]]&/@(Cases[#,Subscript[l, _],Infinity]&/@foo1))-foo1;
aShift=If[SameQ[#,{}],
Flatten[Solve[#==0,DeleteDuplicates[Cases[#,Subscript[a, _],Infinity]]]&[(#-(#//.Subscript[p, _]|Subscript[a, _]:>0))&[filteredList[Select[AllEliminate\[CapitalLambda]/.Subscript[l, i_]:>Subscript[l, i]+Subscript[a, i],!FreeQ[#,Subscript[l, _]]&]]//.Rule[a_,b_]:>b]]],
#]&[Flatten[Solve[#==0,DeleteDuplicates[Cases[#,Subscript[a, _],Infinity]]]&[foo2]]];
lShift=Table[Subscript[l, ii]->Subscript[l, ii]+Subscript[a, ii],{ii,noLoops}]//.aShift//.Subscript[a, _]:>0;
Return[{aShift,lShift}];
];
LBL[edges2_List,nodes_List,loopEdges_,verboseTrueOrFalse_: False]:=Module[{Substitutions},
edges={#[[1]],#[[-1]]^2}&/@edges2;
(*generate temp kinematics:*)
Substitutions=GenerateKinematics[Length[nodes]];
(*graph numbers:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#," vertices = "],Nothing]&[vertices=Join[edges[[All,1]],nodes[[All,1]]]//Flatten//DeleteDuplicates//Sort];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"noEdges ="],Nothing]&[noEdges=Length[edges]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"noVertices ="],Nothing]&[noVertices=Length[vertices]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"noLoops ="],Nothing]&[noLoops=1+noEdges-noVertices];
(*Assign momenta to the edges; q's will be solved for*)
edgesMomenta=Table[Subscript[q, e],{e,noEdges}];
Do[Echo[edgesMomenta[[loopEdges[[a]]]]=Subscript[l, a],"debug"],{a,Length[loopEdges]}];
(*Write down momentum conservation at every vertex*)
vertexMomenta=Table[0,{v,(*noEdges*)Max[Join[ Select[Flatten[edges],NumericQ],{noEdges}]]}];
(*Note: Here we assume that vertices are ordered 1,2,...,noVertices.*)
Echo[edges,"edges"];
Echo[edgesMomenta,"edgesMomenta"];
Echo[vertexMomenta,"vertexMomenta"];
(*Loop over edges to update vertexMomenta*)
Do[
Echo[e=edges[[i,1]],"debug"];
vertexMomenta[[e[[1]]]]-=edgesMomenta[[i]];
vertexMomenta[[e[[2]]]]+=edgesMomenta[[i]];
,{i,noEdges}];
(*Adapt the nodes notation in terms of M, instead of p:*)
nodeMomenta=(#(*Assuming that that last momenta is linear dependent:*)/.#[[-1]]:>(Plus@@(-#[[1;;-2]])))&[Table[Subscript[p, ii],{ii,Length[nodes]}]];
nodes2=Table[{nodes[[ii]][[1]],nodeMomenta[[ii]]},{ii,Length[nodes]}];
Do[
vertexMomenta[[v[[1]]]]+=v[[2]];
,{v,nodes2}];
(*Rule that takes masses from substitution to values input in nodes[[i,2]]:*)
If[Length[Substitutions]>1,
substitutions=Substitutions/.(Thread[SortBy[DeleteDuplicates[Cases[Substitutions,Subscript[M, _],Infinity]],-LeafCount[#]&]->#]&[Table[nodes[[ii,2]],{ii,Length[nodes]}]]),
substitutions=Substitutions
];
MySubstitutions=substitutions;
(*Solve for momentum conservation:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"edgesMomenta = "],Nothing]&[edgesMomenta=(If[#1=={},FLAG,edgesMomenta/.(#1[[1]])]&[Solve[vertexMomenta==0,Cases[Variables[edgesMomenta],Subscript[q, _]]]])];
If[SameQ[edgesMomenta,FLAG],
Print[Style["Cannot solve for momentum conservation! Are you sure the choice of LoopEdges is correct?",Bold,Red]];Abort[],
(*Write on-shell conditions:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"onShellConditions = "],Nothing]&[onShellConditions=Table[edgesMomenta[[i]]\[CenterDot]edgesMomenta[[i]]-edges[[i,2]],{i,noEdges}]//.substitutions];
(*Kinematic invariants:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"allInvariants = "],Nothing]&[allInvariants=Variables[onShellConditions]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"loopInvariants = "],Nothing]&[loopInvariants=Cases[allInvariants,Subscript[l, _]\[CenterDot]_]];
(*seeds for the loop:*)
extraPropagators={};
eliminate\[CapitalLambda][0]={};
(*The main loop over the independent loop momenta:*)
LE=Table[
If[SameQ[verboseTrueOrFalse,True],Echo["------- Looking at loop "<>ToString[a]<>"...-------"],Nothing];
loopMomenta=Select[Join[edgesMomenta,extraPropagators]//.Flatten[Table[eliminate\[CapitalLambda][A],{A,0,a-1}]],!FreeQ[#,Subscript[l, a]]&];
loopMomenta=Select[loopMomenta,Intersection[Variables[#],Table[Subscript[l, b],{b,a-1}]]==={}&];(*keep only those not used before*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,ToString[a]<>") loopMomenta = "],Nothing]&[loopMomenta=DeleteDuplicates[(#/D[#,Subscript[l, a]])&/@loopMomenta]];(*bring into the form Subscript[l, a] + ...*)
(*Added to reduce superfluous scalar products:*)
loopMOMENTA[a]=loopMomenta;
ansatz[a]=Table[Subscript[l, a]+\[CapitalLambda][a][ii],{ii,Length[loopMOMENTA[a]]}];
eliminate\[CapitalLambda]TEMP[a]=Thread[Array[\[CapitalLambda][a],Length[#1]]->#1]&[loopMOMENTA[a]/.Subscript[l, a]:>0];
trivialRule=DeleteCases[eliminate\[CapitalLambda]TEMP[a]/.Rule[a_,b_]/;b=!=0:>dummy,dummy];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Lambda map = "],Nothing]&[eliminate\[CapitalLambda][a]=DeleteCases[eliminate\[CapitalLambda]TEMP[a],Alternatives@@trivialRule]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Loop momenta = "],Nothing]&[loopMomenta=ansatz[a]/.trivialRule];
(*Construct the revelant Gram matrix*)
Gram=Expand[Table[Subscript[v, 1]\[CenterDot]Subscript[v, 2],{Subscript[v, 1],loopMomenta},{Subscript[v, 2],loopMomenta}]]//.substitutions;
gramLoop[a]=Gram;
extraPropagators=Join[extraPropagators,Flatten[Table[loopMomenta[[j]]-loopMomenta[[i]],{i,Length[loopMomenta]},{j,i+1,Length[loopMomenta]}]]];
(*Compute the external Gram determinant*)
externalGram=Table[(Subscript[v, 1]-Subscript[l, a])\[CenterDot](Subscript[v, 2]-Subscript[l, a]),{Subscript[v, 1],Complement[loopMomenta,{Subscript[l, a]}]},{Subscript[v, 2],Complement[loopMomenta,{Subscript[l, a]}]}]//Expand[#]//.substitutions&;
externalGram=If[SameQ[externalGram,{}],{{1}},externalGram];
gramExt[a]=externalGram;
If[SameQ[verboseTrueOrFalse,True],Echo["------- Done with loop "<>ToString[a]<>"!-------"],Nothing];
MatrixForm/@{gramExt[a],gramLoop[a]}
,{a,noLoops}];
Echo[Style["------- Done with all loops! Summary: -------",Blue]];
(*kinematic used:*)
Echo[substitutions,"Kinematic substitutions ="];
(*record some variables:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Eliminate \[CapitalLambda] ="],Nothing]&[AllEliminate\[CapitalLambda]=Flatten[Table[eliminate\[CapitalLambda][A],{A,noLoops}]]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Is there any relations between the \[CapitalLambda]s found above? ="],Nothing]&[relLamdas=If[SameQ[#,{DUMMY,dummy}],NONE,DeleteCases[#,dummy->DUMMY]]&[
(List@@LogicalExpand[(Eliminate[(#//.Rule[a_,b_]:>a-b)==0,DeleteDuplicates[Cases[#,Subscript[_,_],Infinity]]]&&dummy==DUMMY)&[AllEliminate\[CapitalLambda]]])/. (lhs_==rhs_):>Thread[(#1[[1]]->#1[[-1]])&[SortBy[{lhs,rhs},Length]]]//.Rule[-A1_,A2_]:>Rule[A1,-A2]
]];
If[SameQ[verboseTrueOrFalse,True],Echo[#," Momenta in terms of Lambda variables = "],Nothing]&[psAs\[CapitalLambda]=Flatten[Solve[(#//.Rule[a_,b_]:>a-b)==0,DeleteDuplicates[Cases[#,Subscript[_,_],Infinity]]]&[AllEliminate\[CapitalLambda]//.If[SameQ[relLamdas,NONE],{},relLamdas]]]];
If[SameQ[verboseTrueOrFalse,True],Echo[#,"\[CapitalLambda]s depending on ls = "],Nothing]&[loopBack=If[SameQ[#,{}],NONE,#]&[
Quiet[Flatten[Solve[(#//.Rule[a_,b_]:>a-b)==0,Select[DeleteDuplicates[Cases[#,\[CapitalLambda][_][_],Infinity]],!FreeQ[#//.AllEliminate\[CapitalLambda],Subscript[l, __]]&]]&[Select[psAs\[CapitalLambda],!FreeQ[#,Subscript[l, _]]&]]]&[Select[psAs\[CapitalLambda],!FreeQ[#,Subscript[l, _]]&]]]
]];
(*expected (minimal) number of integration variables:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Number of expected scalar products (integration variables) = "],Nothing]&[nLBL=noLoops+Length[AllEliminate\[CapitalLambda]]];
(*Function to detect if loop momentum shifts are needed:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Shift in loop momenta = "],Nothing]&[shift=If[Length[DeleteDuplicates[Cases[Flatten[LE//.AllEliminate\[CapitalLambda],1],Subscript[l, _]\[CenterDot]_,Infinity]]]-nLBL>0,
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Looking for loop momenta shift..."],#]&[FindLoopMomShift[AllEliminate\[CapitalLambda]][[-1]]],
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Number of integration variables already minimized! Proceeding..."],#]&[{}]
]];
(*final on-shell conditions solved:*)
onShellConditions2=onShellConditions/.shift//.substitutions//Simplify;
MyPropagators=onShellConditions2;
temp[0]=onShellConditions2;
sol[0]={};
Do[
sol[a]=Flatten[Quiet@Solve[#==0,DeleteDuplicates[Cases[#,Subscript[l, a]\[CenterDot]_,Infinity]]]&[Select[onShellConditions2//.Flatten[Table[sol[b-1],{b,a}]],!FreeQ[#,Subscript[l, a]]&]]]
,{a,noLoops}];
SolvedOnShellCond=Flatten[Simplify[Table[sol[a],{a,noLoops}]]];
(*return loop output:*)
out000=Simplify[Flatten[Expand[Expand[Expand[Expand[LE]//.AllEliminate\[CapitalLambda]]/.shift]//.substitutions],1]];
(*looking for rank drop:*)
out=rankDropRule[out000];
(*check the number of variables is minimized:*)
If[SameQ[Length[DeleteDuplicates[Cases[out,Subscript[l, _]\[CenterDot]_,Infinity]]],nLBL],
Echo[Style["The number of integration variables ("<>ToString[nLBL]<>") is matching expected bound!",Blue]],
If[
Echo[Style["It seems like the number of integration variables ("<>ToString[Length[DeleteDuplicates[Cases[out,Subscript[l, _]\[CenterDot]_,Infinity]]]]<>") is below expected bound!",Green]],
Echo[Style["It seems like the number of integration variables ("<>ToString[Length[DeleteDuplicates[Cases[out,Subscript[l, _]\[CenterDot]_,Infinity]]]]<>") is above expected bound! You should probably reconsider the input of loop edges.",Red]]
]
];
(*final answer and things to print:*)
If[SameQ[verboseTrueOrFalse,True],Echo[#,"Edges momenta (after potential shift) = "],Nothing]&[finalEdgeMom=edgesMomenta/.shift];
Return[out];
];
];
Options[SOFIABaikov]={LoopEdges->Automatic,ShowXs->False,ShowDetailedDiagram->True,MaxCut->False,Dimension->dim};
SOFIABaikov[edgesnodes_,opts:OptionsPattern[]]:=SOFIABaikov[edgesnodes[[1]],edgesnodes[[-1]],opts];
SOFIABaikov[edges_,nodes_,opts:OptionsPattern[]]:=
EchoTiming[QuietEcho[
Module[{momLabel,EdgeLabels,ShowXsDeFinition,ShowDetailedDiagraM,MaximalCuT,SetDimensioN},
{EdgeLabels,ShowXsDeFinition,ShowDetailedDiagraM,MaximalCuT,SetDimensioN}=OptionValue[{LoopEdges,ShowXs,ShowDetailedDiagram,MaxCut,Dimension}];
momLabel=If[SameQ[EdgeLabels,Automatic],Echo[FixLoopEdges[Join[{edges},{nodes}]],"Choice of loop edges made by the code:"],EdgeLabels]//QuietEcho;
momLabel000=momLabel;
data=LBL[edges,nodes,momLabel];
(*find the change of variables where the propagors + ISPs are integration variables:*)
sol1=Flatten[Simplify[Solve[#1==0,SolvedOnShellCond//.Rule[a_,b_]:>a]]]&[(#-Array[x,Length[#1]]&[onShellConditions2])];
ISP1=Thread[#1->x/@Range[Length[SolvedOnShellCond]+1,Length[SolvedOnShellCond]+Length[#1]]]&[DeleteDuplicates[Cases[sol1/.Rule[a_,b_]:>b,_\[CenterDot]_,Infinity]]];
sol2=Join[sol1//.ISP1,ISP1];
ISP2=Thread[#1->x/@Range[Length[sol2]+1,Length[sol2]+Length[#1]]]&[DeleteDuplicates[Cases[data//.sol2//Factor,_\[CenterDot]_,Infinity]]];
Echo[solFinal=Join[sol2,ISP2]//.x[i_]:>ToExpression["x"<>ToString[i]],"Change of variables to propagator basis = "];
Echo[takeMaxCut=Thread[Array[x,Length[#1]]->ConstantArray[0,Length[#1]]]&[onShellConditions2]//.x[i_]:>ToExpression["x"<>ToString[i]],"Maximal cut conditions = "];
Echo[matrices=Simplify[(out//.solFinal)],"Uncut external (odd positions) and internal (even positions) Gram matrices = "];
(*List of E's:*)
Elist=If[SameQ[#[[1]],\!\(\*
TagBox[
RowBox[{"{", 
RowBox[{"{", "1", "}"}], "}"}],
Function[BoxForm`e$, MatrixForm[BoxForm`e$]]]\)],0,Length[#[[1]]]]&/@(#1[[Select[Range[Length[#1]],OddQ[#]&]]]&[matrices]);
(*List the x's:*)
xs=SortBy[DeleteDuplicates[Cases[Factor[Det[#[[1]]]&/@matrices],x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]],StringLength@ToString[#]&];
xs000=SortBy[DeleteDuplicates[Cases[solFinal//.Rule[a_,b_]:>a-b,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]],StringLength@ToString[#]&];
xsExpanded=Flatten[solFinal//.Rule[a_,b_]:>a-b//Solve[#==0,xs000]&];
(*Shuffle the xs definitions according to ++1 pattern:*)
ttemp1=SortBy[DeleteDuplicates[Cases[matrices,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]],StringLength@ToString[#]&];
ttemp2=SortBy[DeleteDuplicates[Cases[xsExpanded,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]],StringLength@ToString[#]&];
shuffleXs=Thread[Join[ttemp1,DeleteCases[ttemp2,Alternatives@@ttemp1]]->ttemp2];
xs=xs/.shuffleXs;
xs000=xs000/.shuffleXs;
matrices=matrices/.shuffleXs;
xsExpanded=xsExpanded/.shuffleXs;
(*Put things together:*)
If[SameQ[ShowXsDeFinition,False],Nothing,Print["x's in terms of dot products:",xsExpanded]];
If[SameQ[ShowDetailedDiagraM,True],Print[{FeynmanPlot[edges,nodes,xsExpanded[[1;;Length[finalEdgeMom]]][[All,1]],momLabel000],
			FeynmanPlot[edges,nodes,finalEdgeMom,momLabel000]}],Nothing];
(*Measure zero tests:*)
matricesPairs=Partition[matrices//.Transpose[A___]:>{{1}},2];
matricesPairsMC={Det[#[[1]][[1]]],Det[#[[-1]][[1]]]}&/@(matricesPairs//.takeMaxCut);
matricesPairsMC=DeleteCases[matricesPairsMC,{a_,b_}/;FreeQ[{a,b},_Symbol?(StringMatchQ[SymbolName[#],"x"~~DigitCharacter..]&)]];
mzFLAG=If[SameQ[Cases[matricesPairsMC,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}],{}],
Null,
If[SameQ[#1,{}],
Null,
True
]&[Flatten[Position[Cases[#,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]&/@(Select[Factor[#[[-1]]/#[[1]]]&/@matricesPairsMC,! NumericQ[#] || # <= 0 &]),{}]]
  ]
  ];
(*Integrand*)
prefactor=((-2^(noLoops-Length[xs]) (-I)^noLoops Pi^((noLoops-Length[xs])/2))/Product[Gamma[(dim-Elist[[ii]])/2],{ii,Length[Elist]}]);
integrand=(((-2^(noLoops-Length[xs]) (-I)^noLoops Pi^((noLoops-Length[xs])/2))/Product[Gamma[(dim-Elist[[ii]])/2],{ii,Length[Elist]}])(((Wedge@@Map[d[#]&,#1//.\[Nu][__]:>1])(Times@@If[Length[onShellConditions2]==Length[#1],1,#[[Length[onShellConditions2]+1;;-1]]]/Times@@(#[[;;Length[onShellConditions2]]])))&[#^\[Nu]/@Range[Length[#]]&[xs]])(Times@@(Table[Det[#1[[ii]][[1]][[1]]]^((Elist[[ii]]-dim+1)/2) Det[#1[[ii]][[-1]][[1]]]^((dim-Elist[[ii]]-2)/2),{ii,Length[#1]}]&[(*Partition[matrices,2]*)matricesPairs])))/.Wedge[AAA_]:>AAA;
If[SameQ[MaximalCuT,False],
Return[Echo[If[SameQ[SetDimensioN,dim],
integrand,
If[SameQ[Factor[prefactor//.dim->SetDimensioN],0],
Print[Style["Warning: The constant prefactor of the Baikov integrand vanishes. Please use dimensional regularization, such as Dimension->4-2ep.", Bold, Red]],
integrand//.dim->SetDimensioN]],"Uncut LBL Baikov = "]],
If[SameQ[Factor[prefactor//.dim->SetDimensioN],0],
Print[Style["Warning: The constant prefactor of the Baikov integrand vanishes. Please use dimensional regularization, such as Dimension->4-2ep.",Bold, Red]],
Nothing];
Return[TakeMaxCut[integrand,{dim->SetDimensioN}]]
];
]],"Total runtime= "];
Clear[TakeMaxCut];
TakeMaxCut[lblIntegrand_,dimRule_:{}]:=QuietEcho[Module[{},
Clear[propsX,\[Nu]Map,maxcut];
propsX=xs[[;;Length[onShellConditions2]]];
\[Nu]Map=Thread[#->ConstantArray[1,Length[#1]]]&[\[Nu]/@Range[Length[onShellConditions2]]];
maxcut=1/(2Pi I)^Length[propsX] (((Times@@propsX)(integrand/.\[Nu]Map/.Join[{\[Nu][i_]:>0},dimRule]))//.takeMaxCut//.Wedge@@{a___,d[0],b___}:>Wedge@@{a,b}//.Wedge[]:>1//.Wedge[d[a_]]:>d[a]);
Return[Echo[maxcut,"Maximal cut LBL Baikov = "]];
]];

(*Prepare the singularity system:*)
prepareLandauSystem[Edges_,Nodes_,MomLabel_,optionMaxCut_,optionJulia_]:=Module[{inutile1,inutile2,inutile3,Glist,GlistOS,listOfDet},
inutile1=QuietEcho[SOFIABaikov[Edges,Nodes,LoopEdges->MomLabel,ShowXs->False,ShowDetailedDiagram->False]];
inutile2=QuietEcho[TakeMaxCut[integrand]];
Glist=matrices;
GlistOS=MatrixForm[#[[1]]]&/@(Glist//. If[SameQ[optionMaxCut,True],takeMaxCut,{}]);
gramList=homogeneizeKin[Det[#[[1]]]&/@GlistOS];
active=DeleteDuplicates[Cases[gramList,x_Symbol/;StringMatchQ[SymbolName[x],"x"~~DigitCharacter..],{0,Infinity}]];
inutile3=If[SameQ[optionJulia,True],QuietEcho[sendSystemToJulia[gramList]],{}];
Return[gramList];
];

(*Symmetries:*)
Clear[Symmetry];
Symmetry[edgenode1_,edgenode2_]:= Symmetry[edgenode1,edgenode2]=Module[{f,massorganizer,edges1,edges2,edgelist1,edgelist2,multiedgepos1,multiedgepos2,color1,color2,simpleedge1,simplegraph1,simpleedge2,simplegraph2,vertexrule,simpleedge1to2,edgepos1to2,intmass1to2,symmetries1to2,multisymmetries1to2,masses1to2,masses1to2b,masses1to2c,sym,multisymmetries1to2b,EnoughScalesQ,multisymmetries1to2c,vtomomenta,vtoM,massrepls,massmomorganizer,momrepls,Mext2to1,mint2to1,multisymmetries1to2d,next1,next2,kinematics1,kinematics2,intermediate2,intermediate1,CyclicBasis,intermom12,intermom12b,p1s,p2s,s1s,s2s,s1to2,extmasses,bestchoice , dominant, finalrepls,nodes1,nodes2,intmass1,intmass2,multi,multisymmetries1to2g,interfinal,dominant2,multisinglerepls,extscales,extmassesr,intscales,intmasses,intmassesr,extrepls,nodes1r,nodes2r,intrepls,Mext2to1b,Mext2to1final,mint2to1b,mint2to1final,system,systemfinal,v1,v2,vfirst,vsecond,invmassrepls,sol1,sol2,sol21,sol22,sol31,sol32,solfinal1,solfinal2,posfail1,soltrue1,soltrue2,dfirst,dsecond,solfinal,false},
edges1=edgenode1[[1]];nodes1=edgenode1[[2]]; edges2=edgenode2[[1]];nodes2=edgenode2[[2]];
If[UnsameQ[Length[edges1],Length[edges2]], (*checks immediately if number of edges is the same*)
{},
edgelist1=Sort/@Transpose[edges1][[1]];intmass1=Transpose[edges1][[2]]; 
edgelist2=Sort/@Transpose[edges2][[1]]; intmass2=Transpose[edges2][[2]]; 
multiedgepos1=Sort/@(Table[Flatten[Position[edgelist1,edgelist1[[j]]]],{j,1,edgelist1//Length}]//DeleteDuplicates);
multiedgepos2=Sort/@(Table[Flatten[Position[edgelist2,edgelist2[[j]]]],{j,1,edgelist2//Length}]//DeleteDuplicates);
If[UnsameQ[Sort[Length/@multiedgepos1],Sort[Length/@multiedgepos2]], (*tests if distribution of multi edges matches*)
{},
color1=Thread/@Thread[f[multiedgepos1]]/.f[x_]:>Part[intmass1,x];
simpleedge1=Table[edgelist1[[multiedgepos1[[j,1]]]],{j,1,multiedgepos1//Length}];
simplegraph1=#[[1]]\[UndirectedEdge]#[[2]]&/@simpleedge1;
color2=Thread/@Thread[f[multiedgepos2]]/.f[x_]:>Part[intmass2,x];
simpleedge2=Table[edgelist2[[multiedgepos2[[j,1]]]],{j,1,multiedgepos2//Length}];
simplegraph2=#[[1]]\[UndirectedEdge]#[[2]]&/@simpleedge2;
vertexrule=FindGraphIsomorphism[simplegraph1,simplegraph2,All]//Normal; 
If[SameQ[vertexrule,{}],(*tests if simple graphs are the same*)
{},
simpleedge1to2=Map[Sort,simpleedge1/.vertexrule,{2}];
edgepos1to2=Table[Position[simpleedge1to2[[i]],simpleedge2[[j]]][[1,1]],{i,1,simpleedge1to2//Length},{j,1,simpleedge2//Length}];
intmass1to2=Table[{color1[[edgepos1to2[[j]]]],color2}//Transpose,{j,1,edgepos1to2//Length}];
symmetries1to2={vertexrule,intmass1to2}//Transpose;
multisymmetries1to2=Select[symmetries1to2,And@@(SameQ@@#&/@Sort/@Map[Length,#[[2]],{2}])&];(*selects symmetries that preserve multi edges*)
If[SameQ[multisymmetries1to2,{}], 
{},
(*organizes mass replacements including multi-edge permutations:*)
masses1to2=Transpose[multisymmetries1to2][[2]];
masses1to2b=Map[If[Length[#[[1]]]==1, {#[[1,1]],#[[2,1]]},Transpose/@Table[{#[[1]],Permutations[#[[2]]][[j]]},{j,1,Permutations[#[[2]]]//Length}]]&,masses1to2,{2}];
massorganizer[input_]:=With[{nested=Select[input,ArrayDepth[#]>2&],extra=Select[input,ArrayDepth[#]<=2&]},If[nested==={},{input},Map[Map[Join[#,extra]&,#]&,nested][[1]]]];
masses1to2c=massorganizer/@masses1to2b(*/. {0,0}:>Sequence[]*);
sym=Transpose[multisymmetries1to2][[1]];
multisymmetries1to2b ={#[[1]],DeleteDuplicates[#[[2]]]}&/@Flatten[Table[Table[{sym[[i]],masses1to2c[[i,j]]},{j,1,masses1to2c[[i]]//Length}],{i,1,masses1to2c//Length}],1];
(*EnoughScalesQ=Module[{var},var=Transpose[#[[2]]]; If[Times@@(Count[#,0]&/@var)>0,False, Or@@(DuplicateFreeQ/@var)]]&*);
EnoughScalesQ=Module[{var,var2,var3,var4},var=#;  
If[ Or@@(DuplicateFreeQ/@Transpose[var]), var2=var/.{0,0}->Sequence[];
If[SameQ[var2,{}],True, var3= Position[Transpose[var2],0];
If[SameQ[var3,{}],True,var4=DeleteDuplicates[Transpose[var3][[1]]];
If[Length[var4]>1,False, Transpose[var2][[3-var4[[1]]]]//DuplicateFreeQ
]]],False]]&;
 (*checks if the same mass scale is being replaced twice, and if massless is not assigned any replacement to a non-zero mass*)
multisymmetries1to2c=Select[multisymmetries1to2b,EnoughScalesQ[#[[2]]]&];
If[SameQ[multisymmetries1to2c,{}],(*checks if there are enough internal mass scales to make a replacement*)
{},
next1=Length[nodes1];next2=Length[nodes2];
extmasses={Transpose[nodes1][[2]],Transpose[nodes2][[2]]};
extscales=DeleteCases[#,0]&/@DeleteDuplicates/@extmasses (*needs changing if we want to include masses with numerical values not just 0*);extrepls={Table[extscales[[1,i]]->Subscript[M1, i],{i,1,extscales[[1]]//Length}],Table[extscales[[2,i]]->Subscript[M2, i],{i,1,extscales[[2]]//Length}]};
extmassesr={extmasses[[1]]/.extrepls[[1]],extmasses[[2]]/.extrepls[[2]]};
nodes1r=nodes1/.extrepls[[1]]; nodes2r=nodes2/.extrepls[[2]];
intmasses={intmass1,intmass2};
intscales=DeleteCases[#,0]&/@DeleteDuplicates/@intmasses(*needs changing if we want to include masses with numerical values not just 0*);
intrepls={Table[intscales[[1,i]]->Subscript[m1, i],{i,1,intscales[[1]]//Length}],Table[intscales[[2,i]]->Subscript[m2, i],{i,1,intscales[[2]]//Length}]};
intmassesr={intmasses[[1]]/.intrepls[[1]],intmasses[[2]]/.intrepls[[2]]};
vtomomenta[vrepls_]:=Transpose[{Flatten[Position[Transpose[nodes1r][[1]],#]&/@Transpose[List@@@vrepls][[1]],{3}][[1]],Flatten[Position[Transpose[nodes2r][[1]],#]&/@Transpose[List@@@vrepls][[2]],{3}][[1]]}];
vtoM[vrepls_]:=Transpose[{Part[Transpose[nodes1r][[2]],#]&/@Flatten[Position[Transpose[nodes1r][[1]],#]&/@Transpose[List@@@vrepls][[1]],{3}][[1]],Part[Transpose[nodes2r][[2]],#]&/@Flatten[Position[Transpose[nodes2r][[1]],#]&/@Transpose[List@@@vrepls][[2]],{3}][[1]]}](*/. {}:>Sequence[]*);
massrepls=vtoM/@Transpose[multisymmetries1to2c][[1]];
momrepls=vtomomenta/@Transpose[multisymmetries1to2c][[1]];
massmomorganizer[entry_]:=If[SameQ[Length/@entry[[1]],{1,1}],Flatten[First[entry]]^2,
If[Length[entry[[1,1]]]==1,{entry[[1,1,1]]^2,s@@Sort[entry[[2,2]]]},If[Length[entry[[1,2]]]==1,{s@@Sort[entry[[2,1]]],entry[[1,2,1]]^2},{s@@Sort[entry[[2,1]]],s@@Sort[entry[[2,2]]]}]  ]];
Mext2to1=Table[massmomorganizer/@Transpose[{massrepls[[j]],momrepls[[j]]}],{j,1,momrepls//Length}];
mint2to1=Transpose[multisymmetries1to2c][[2]];
kinematics1=GenerateKinematics[next1]/.Subscript[M, i_]:>extmassesr[[1,i]]/.Subscript[s, x___]->Subscript[s1, x]/.Subscript[p, x_]->Subscript[p1, x]//Quiet;(*save in memory?*);
kinematics2=GenerateKinematics[next2]/.Subscript[M, i_]:>extmassesr[[2,i]]/.Subscript[s, x___]->Subscript[s2, x]/.Subscript[p, x_]->Subscript[p2, x]//Quiet;
Mext2to1b=({#[[1]]/.s[x___]:>Total[Subscript[p1, #]&/@{x}]\[CenterDot]Total[Subscript[p1, #]&/@{x}],#[[2]]/.s[x___]:>Total[Subscript[p2, #]&/@{x}]\[CenterDot]Total[Subscript[p2, #]&/@{x}]}&/@Transpose/@Mext2to1)/.kinematics1/.kinematics2;
Mext2to1final=DeleteDuplicates/@Transpose/@Mext2to1b;
mint2to1b=(Transpose/@mint2to1);
mint2to1final=Transpose/@Table[{mint2to1b[[j,1]]/.intrepls[[1]],mint2to1b[[j,2]]/.intrepls[[2]]},{j,1,mint2to1b//Length}];
CyclicBasis[n_]:=CyclicBasis[n]=Flatten[Table[Subscript[s, Sequence@@Sort[Mod[Range[a,a+l],n,1]]],{l,1,n/2-1},{a,If[l==n/2-1,n/2,n]}]];
intermom12=Transpose/@Transpose[{Map[Subscript[p1, #]&,Transpose[Transpose/@momrepls][[1]],{3}],Map[Subscript[p2, #]&,Transpose[Transpose/@momrepls][[2]],{3}]}];
intermom12b=Map[Total[#]&,intermom12,{3}];
p1s=Transpose[Transpose/@intermom12b][[1]];
p2s=Transpose[Transpose/@intermom12b][[2]];
s1s=Table[CyclicBasis[p1s[[i]]//Length]/.Subscript[s, x___]:>Total[p1s[[i,#]]&/@{x}]\[CenterDot]Total[p1s[[i,#]]&/@{x}],{i,1,p1s//Length}]/.kinematics1;
s2s=Table[CyclicBasis[p2s[[i]]//Length]/.Subscript[s, x___]:>Total[p2s[[i,#]]&/@{x}]\[CenterDot]Total[p2s[[i,#]]&/@{x}],{i,1,p2s//Length}]/.kinematics2;
s1to2=DeleteDuplicates/@Transpose/@Transpose[{s1s,s2s}];
multisymmetries1to2d={s1to2,Mext2to1final,mint2to1final};
system=(DeleteDuplicates/@(Flatten[#,1]&/@Transpose[multisymmetries1to2d]))/.{Subscript[M1, x_]^2->Subscript[MM1, x],Subscript[M2, x_]^2->Subscript[MM2, x]};
systemfinal=Flatten/@Map[Replace[#,{x_,y_}->{x==y}]&,system,{2}];
v1=Join[CyclicBasis[next1]/.Subscript[s, x___]->Subscript[s1, x],Table[Subscript[MM1, i],{i,1,extscales[[1]]//Length}],Table[Subscript[m1, i],{i,1,intscales[[1]]//Length}]];
v2=Join[CyclicBasis[next2]/.Subscript[s, x___]->Subscript[s2, x],Table[Subscript[MM2, i],{i,1,extscales[[2]]//Length}],Table[Subscript[m2, i],{i,1,intscales[[2]]//Length}]];
If[Length[intscales[[1]]]>=Length[intscales[[2]]],
vfirst=v1; dfirst=1;vsecond=v2; dsecond=2;,
vfirst=v2; dfirst=2;vsecond=v1; dsecond=1;];
invmassrepls=Map[Rule@@@Reverse,Flatten[#,1]&/@Transpose[{extrepls,intrepls}],2]//Flatten;
(*If[SameQ[dominant,0],*);
sol1=Quiet[Solve[#,vfirst]&/@systemfinal]; (*Linear solve?*);
posfail1=Flatten[Position[sol1,{}]];
sol2=Quiet[Solve[#,vsecond]&/@systemfinal[[posfail1]]];
If[SameQ[sol1,Table[{},Length[sol1]]]&&SameQ[sol2,Table[{},Length[sol2]]],solfinal=false,
soltrue1=Flatten/@sol1;
sol21=soltrue1/.{Subscript[MM1, x_]->Subscript[M1, x]^2,Subscript[MM2, x_]->Subscript[M2, x]^2,Subscript[s1, x___]->Subscript[s, x],Subscript[s2, x___]->Subscript[s, x]}/.invmassrepls;
sol31=DeleteDuplicates/@(Select[#,UnsameQ[#[[1]],#[[2]]]&]&/@sol21);
solfinal1=Transpose[{Table[dfirst,sol31//Length],sol31}];
soltrue2=Flatten/@sol2;
sol22=soltrue2/.{Subscript[MM1, x_]->Subscript[M1, x]^2,Subscript[MM2, x_]->Subscript[M2, x]^2,Subscript[s1, x___]->Subscript[s, x],Subscript[s2, x___]->Subscript[s, x]}/.invmassrepls;
sol32=DeleteDuplicates/@(Select[#,UnsameQ[#[[1]],#[[2]]]&]&/@sol22);
solfinal2=Transpose[{Table[dsecond,sol32//Length],sol32}];
solfinal=Select[Join[solfinal1,solfinal2],UnsameQ[#[[2]],{}]&]];
If[SameQ[solfinal,false],{},  (*no solution for mass replacements -> no symmetry*)
If[SameQ[solfinal,{}],{edgenode1,{}}, (*trivial symmetry, e.g. a reflection*)
bestchoice=SortBy[solfinal,Length[#[[2]]]&][[1]] (*Length is not the best criteria, needs to prioritize trivial replacements a->b*);
If[#[[1]]==2,{edgenode2,#[[2]]},{edgenode1,#[[2]]}]&[bestchoice]]
]]]]]]];
BestDiagram[objects_]:=BestDiagram[First[objects],Rest[objects]];
BestDiagram[first_,objects_]:=Module[{best,uncomparables={}},best=first;
Do[Module[{result=Symmetry[best,objects[[i]]]},Which[result==={},AppendTo[uncomparables,objects[[i]]],result[[1]]===best,Null,result[[1]]===objects[[i]],best=objects[[i]] ]]
,{i,1,objects//Length}];
{best,uncomparables}];
BestDiagram2[objects_]:=Module[{i,out}, i=1;out[0]={{},{}}; out[1]={First[objects],Rest[objects]};
While[UnsameQ[Length[out[i-1][[2]]]-Length[out[i][[2]]],0],
out[i+1]=BestDiagram[out[i][[1]],out[i][[2]]];  i++];
 {{out[i][[1]],Complement[objects,Join[{out[i][[1]]},out[i][[2]]]]},out[i][[2]]}];
BestDiagram3[objects_]:=Module[{i,out},i=1; out[1]=BestDiagram2[objects];
 While[UnsameQ[out[i][[2]],{}], out[i+1]=BestDiagram2[out[i][[2]]];  i++;];
Table[out[j][[1]],{j,1,i}]];
SymmetryQuotient0[objects_]:= Module[{i,out,diagrams},i=1; diagrams=BestDiagram3[objects];
Table[{diagrams[[i,1]],Symmetry[diagrams[[i,1]],#][[2]]&/@diagrams[[i,2]]},{i,1,diagrams//Length}]];
SymmetryQuotient[objects_]:= {#[[1]],DeleteDuplicates[#[[2]]]}&/@ SymmetryQuotient0[objects];

(*SOFIASingularities:*)
(*This command can be used to setup the Landau analysis with many options:*)
Options[SOFIASingularitiesSEED]={IncludeISPs->False,Substitutions->{},LoopEdges->Automatic,MaxCut->True,Solver->FastFubini,LaunchJulia->False,SolverBound->100,FiniteFieldsModulus->0,FactorResult->True,PLDMethod->sym,PLDHomogeneous->true,PLDHighPrecision->false,PLDCodimStart->-1,PLDFaceStart->1,PLDRunASingleFace->false};
SOFIASingularitiesSEED[edgenode_,opts:OptionsPattern[]]:=Module[{ISPSIN,nUmerics,momLabel,landau0,EdgeLabels,sOlver,MaximalCut,RunJulia,lImit,mOdulus,fActorLast,PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe},
{ISPSIN,nUmerics,EdgeLabels,sOlver,MaximalCut,RunJulia,lImit,mOdulus,fActorLast,PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe}=OptionValue[{IncludeISPs,Substitutions,LoopEdges,Solver,MaxCut,LaunchJulia,SolverBound,FiniteFieldsModulus,FactorResult,PLDMethod,PLDHomogeneous,PLDHighPrecision,PLDCodimStart,PLDFaceStart,PLDRunASingleFace}];
lImit=If[SameQ[lImit,Infinity],10^200,lImit];
(*Make a choice of edge labels:*)
momLabel=If[SameQ[EdgeLabels,Automatic],Echo[FixLoopEdges[edgenode],"Choice of loop edges made by the code:"],EdgeLabels]//QuietEcho;
(*Prepare the system of equations needed to find Landau singularities:*)
prepareLandauSystem[edgenode[[1]],edgenode[[-1]],momLabel,MaximalCut,(*RunJulia:*)True];
(*Delete constant Gram determinants [including zero!]:*)
gramList=Select[gramList,!NumericQ[#]&];
(*Solve the system of equations:*)
Echo[TableForm[Factor[gramList]],"List of the Gram determinants:"];
Echo[active,"Variables to eliminate:"];
landau0=
If[SameQ[sOlver,momentumPLD],
momentumPLD[Join[{},SortBy[gramList,Length]],PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe],
SortBy[sOlver[
If[SameQ[MaximalCut,True],
Join[If[SameQ[ISPSIN,False],{},active],SortBy[gramList,Length]],
Join[If[SameQ[ISPSIN,False],takeMaxCut[[All,1]],active],SortBy[gramList,Length]]
]//.nUmerics
,
active
,lImit,mOdulus,(*fActorLast*)True],LeafCount[#]&]
];
Return[landau0];
];
(*A final command that puts everything together:*)
leadingTerm[f_]:=Module[{s,poly,ord},s=Normal[Series[f,{\[Delta],0,100}]];poly=Expand[s];ord=Exponent[poly,\[Delta],Min];Return[Coefficient[poly,\[Delta],ord]]];
Options[SOFIASingularities]={
Reflections->False,LoopEdgesSubtopologies->Automatic,ShowPossiblyDegenerate->False(*True*),ShowHistoryGraph->False(*True,SingOnly*),ShowHistory->False,SymmetriesOn->True,IncludeSubtopologies->True,StartAtSubtopology->1,EndAtSubtopology->-1,DebugOptionUnclog->True,UnclogTime->10^17(*Age of the Universe :-)*),
IncludeISPs->False,Substitutions->{},LoopEdges->Automatic,MaxCut->True,Solver->FastFubini,LaunchJulia->False,SolverBound->100,FiniteFieldsModulus->0,FactorResult->True,PLDMethod->sym,PLDHomogeneous->true,PLDHighPrecision->false,PLDCodimStart->-1,PLDFaceStart->1,PLDRunASingleFace->false
};
SOFIASingularities[edgenode_,opts:OptionsPattern[]]:=EchoTiming[Quiet[QuietEcho[Module[
{ReflectionS,listFeynmanPlots,RunContrActed,contractionS,resultFromSeed,StartAtSubtopOlogy,EndAtSubtopOlogy,deCloG,DebugOptionUnclogTimE,SymmetriesON,symOut,symMap,ShowSingOrigiN,listFeynmanPlots000,ShowSingOrigiNTREE,RecordPossiblyInvaliD,fActorLast},
{ReflectionS,RecordPossiblyInvaliD,ShowSingOrigiNTREE,ShowSingOrigiN,SymmetriesON,RunContrActed,StartAtSubtopOlogy,EndAtSubtopOlogy,deCloG,DebugOptionUnclogTimE,fActorLast}=OptionValue[{Reflections,ShowPossiblyDegenerate,ShowHistoryGraph,ShowHistory,SymmetriesOn,IncludeSubtopologies,StartAtSubtopology,EndAtSubtopology,DebugOptionUnclog,UnclogTime,FactorResult}];
contractionS=
If[SameQ[RunContrActed,False],
Nothing,
(Subtopologies[edgenode,ReflectionS])[[StartAtSubtopOlogy;;EndAtSubtopOlogy]]
];
symOut=If[SameQ[SymmetriesON,True],SymmetryQuotient[contractionS]//.{{}}:>{},Null];
symMap=If[SameQ[SymmetriesON,True],#/.Rule[a_,b_]:>Rule[a,b+\[Delta]]&/@(homogeneizeKin[symOut[[All,2]]]//.Sqrt[aaa_]:>aaa(*//.0:>\[Delta]*)),Null];
symMap0000000=symMap;
contractionS=If[SameQ[SymmetriesON,True],symOut[[All,1]],contractionS];
generatedSubtopologies=contractionS;
listFeynmanPlots=Table[FeynmanPlot[#1[[iii]][[1]],#1[[iii]][[-1]],Table[jjj,{jjj,Length[#1[[iii]][[1]]]}],FixLoopEdges[#1[[iii]]]],{iii,Length[#1]}]&[contractionS];
If[IntersectingQ[{ShowSingOrigiNTREE},{True,SingOnly}],listFeynmanPlots000=Table[FeynmanPlot[#1[[iii]][[1]],#1[[iii]][[-1]]],{iii,Length[#1]}]&[contractionS],Null];
resultFromSeed=
If[Position[{opts},momentumPLD]=={},
SortBy[#1,LeafCount[#1]&],#1]&[
If[SameQ[RunContrActed,False],
SOFIASingularitiesSEED[edgenode,FilterRules[{opts},Options[SOFIASingularitiesSEED]]],
timed[
DynamicModule[
  {i = 0, mzFLAGlist = {}, skippedIndices = {},diagTemp={listFeynmanPlots[[1]]}, maxTime = DebugOptionUnclogTimE, declog = deCloG},
  res = Monitor[
    Table[
      i++;
      With[{
        result = 
        If[
          SameQ[declog, True],
          TimeConstrained[
            SOFIASingularitiesSEED[
              contractionS[[j]], 
              FilterRules[{opts}, Options[SOFIASingularitiesSEED]]
            ], 
            maxTime, 
            Nothing
          ],
          SOFIASingularitiesSEED[
            contractionS[[j]], 
            FilterRules[{opts}, Options[SOFIASingularitiesSEED]]
          ]
        ]
      },
      If[
        SameQ[result, Nothing] && SameQ[declog, True],
        If[SameQ[RecordPossiblyInvaliD,True],If[SameQ[mzFLAG,True],AppendTo[mzFLAGlist,j],Nothing],Nothing];
        AppendTo[skippedIndices, j];
        AppendTo[diagTemp,
        If[j<Length[contractionS],listFeynmanPlots[[j+1]],listFeynmanPlots[[j]]]
        ];
        Nothing,
        If[SameQ[RecordPossiblyInvaliD,True],If[SameQ[mzFLAG,True],AppendTo[mzFLAGlist,j],Nothing],Nothing];
        AppendTo[diagTemp,
        If[j<Length[contractionS],listFeynmanPlots[[j+1]],listFeynmanPlots[[j]]]
        ];
        Echo[result,
        If[j<Length[contractionS],listFeynmanPlots[[j+1]],listFeynmanPlots[[j]]]
        ]
      ]
    ],
    {j, Length[contractionS]}
    ],
    Column[{
      ProgressIndicator[Dynamic[i], {0, Length[contractionS]}],
      Dynamic[Row[{"Subtopology ", i, " of ", Length[contractionS]}]],
      Dynamic[Last[diagTemp]],
      If[!SameQ[10^17,DebugOptionUnclogTimE], 
        Dynamic[Style["Unclogging: Skipped over subtopologies " <> ToString[skippedIndices], Red]], 
        Nothing
      ]
    }]
  ];
  If[SameQ[skippedIndices,{}],Null,Print["Final Skipped Indices: ", skippedIndices]];
  If[SameQ[mzFLAGlist,{}],Null,Print[Style["The maximal cut integration contour of the (sub)topologies at position(s) '"<>ToString[mzFLAGlist]<>"' in the internally generated list 'generatedSubtopologies' may be degenerate. In case of doubt, we advise running the singularity analysis on each diagram alone adjusting the LoopEdges -> {...} or MaxCut -> False options to make sure it is complete.", Bold, Orange]]];
];
];
If[IntersectingQ[{ShowSingOrigiNTREE},{True,SingOnly}],
If[SameQ[SymmetriesON,True],
Print["Notice: To see the complete history tree, turn off symmetries with SymmetriesOn->False. Alternatively, you can use the combination of options: ShowHistory->True, SymmetriesOn->True."],
If[SameQ[ShowSingOrigiNTREE,SingOnly],
Print[
HistoryGraph[edgenode]//.Table[
Thread[listFeynmanPlots000[[ii]]->Column[DeleteCases[Select[DeleteDuplicates[Flatten[FactorList[#][[All,1]]&/@res[[ii]]],ProportionalPolynomialsQ[#1,#2,20,0]&],!NumericQ[#]&],Alternatives@@{Det[___],{}[[-1]]}]]],
 {ii, Length[res]}]],
  Print[
  {#1//.Table[
Thread[listFeynmanPlots000[[ii]]->Column[DeleteCases[Select[DeleteDuplicates[Flatten[FactorList[#][[All,1]]&/@res[[ii]]],ProportionalPolynomialsQ[#1,#2,20,0]&],!NumericQ[#]&],Alternatives@@{Det[___],{}[[-1]]}]]],
   {ii, Length[res]}
  ],#1}&[HistoryGraph[edgenode]]]
  ]
  ]
  ,Null];
If[SameQ[ShowSingOrigiN,True],
Print[
 Column[
  Table[
   Row[{
     "Corresponding singularities for ",
     listFeynmanPlots[[ii]],
     " : ",
     TableForm[DeleteCases[Select[DeleteDuplicates[Flatten[FactorList[#][[All,1]]&/@res[[ii]]],ProportionalPolynomialsQ[#1,#2,20,0]&],!NumericQ[#]&],Alternatives@@{Det[___],{}[[-1]]}]]
   }],
   {ii, Length[res]}
  ]
 ]
],
Null];
res=If[SymmetriesON,
  MapThread[
    Function[{elem, sym},
      Flatten[Join[{elem}, {leadingTerm[elem /. sym]}]]
    ],
    {res, symMap}
  ],
  res
];
DeleteCases[Select[DeleteDuplicates[Flatten[
If[SameQ[fActorLast,True],FactorList[#][[All,1]]&/@Flatten[res],Flatten[res]]
],ProportionalPolynomialsQ[#1,#2,(*20*)3,0]&],!NumericQ[#]&],Alternatives@@{Det[___],{}[[-1]]}]
]];
If[SameQ[RunContrActed,False],
If[SameQ[mzFLAG,True],
Print[Style["The maximal cut integration contour of this diagram may be degenerate. We advise running the singularity analysis again adjusting the LoopEdges option to make sure it is complete.", Bold, Orange]],
Null],
Null
];
Return[resultFromSeed];
]]]];
Options[SolvePolynomialSystem]={
Solver->FastFubini,LaunchJulia->False,SolverBound->100,FiniteFieldsModulus->0,FactorResult->True,PLDMethod->sym,PLDHomogeneous->true,PLDHighPrecision->false,PLDCodimStart->-1,PLDFaceStart->1,PLDRunASingleFace->false
};
SolvePolynomialSystem[polynomials_,variables_,opts:OptionsPattern[]]:=SolvePolynomialSystem[polynomials,variables,opts]=Module[
{sOlver,RunJulia,lImit,mOdulus,fActorLast,PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe,sol0},
{sOlver,RunJulia,lImit,mOdulus,fActorLast,PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe}=OptionValue[{Solver,LaunchJulia,SolverBound,FiniteFieldsModulus,FactorResult,PLDMethod,PLDHomogeneous,PLDHighPrecision,PLDCodimStart,PLDFaceStart,PLDRunASingleFace}];
lImit=If[SameQ[lImit,Infinity],10^200,lImit];
(*Solve the system of equations:*)
sol0=
If[SameQ[sOlver,momentumPLD],
momentumPLD[SortBy[polynomials,Length],PLDmethOd,PLDhOm,PLDhP,PLDcodimStaRt,PLDfaceStaRt,PLDsingleFaCe],
SortBy[sOlver[SortBy[polynomials,Length],variables,lImit,mOdulus,fActorLast],LeafCount[#]&]
];
Return[sol0];
];

(*Effortless:*)
Get[Global`SOFIAoptionEffortlessPath];

(*SOFIA wrapper for singularities + Effortless:*)
Options[SOFIA]={
FindLetters->False,AddSing->{},ChangeVariables->{},IncludeExtraPolynomials->{},DoubleRoots->{},AddLetters->{}(*Format: {{E},{O}}*),
Reflections->False,LoopEdgesSubtopologies->Automatic,ShowPossiblyDegenerate->(*False*)True,ShowHistoryGraph->False,ShowHistory->False,SymmetriesOn->True,IncludeSubtopologies->True,StartAtSubtopology->1,EndAtSubtopology->-1,DebugOptionUnclog->True,UnclogTime->10^17,
IncludeISPs->False,Substitutions->{},LoopEdges->Automatic,MaxCut->True,Solver->FastFubini,LaunchJulia->False,SolverBound->100,FiniteFieldsModulus->0,FactorResult->True,PLDMethod->sym,PLDHomogeneous->true,PLDHighPrecision->false,PLDCodimStart->-1,PLDFaceStart->1,PLDRunASingleFace->false
};
SOFIA[edgenode_,opts:OptionsPattern[]]:=EchoTiming[QuietEcho[Module[{AddLetterS,FindLetterS,sing,AddSIng,runEL,ChangeMyVariAbles,IncludeExtraPolynomialS,ExtraRootS,myEven,myRoots,myOdd,myOdd00},
{AddLetterS,FindLetterS,AddSIng,ChangeMyVariAbles,IncludeExtraPolynomialS,ExtraRootS}=OptionValue[{AddLetters,FindLetters,AddSing,ChangeVariables,IncludeExtraPolynomials,DoubleRoots}];
If[SameQ[FindLetterS,False],
sing=
Quiet[If[SameQ[ChangeMyVariAbles,{}],#1,MyFactorList[#1//.ChangeMyVariAbles]]]&[EchoTiming[QuietEcho[Join[SOFIASingularities[edgenode,FilterRules[{opts},Options[SOFIASingularities]]],AddSIng]]],"Candidate singularities found:"];
Return[sing];,
Echo[sing=
Quiet[If[SameQ[ChangeMyVariAbles,{}],#1,MyFactorList[#1//.ChangeMyVariAbles]]]&[EchoTiming[QuietEcho[Join[SOFIASingularities[edgenode,FilterRules[{opts},Options[SOFIASingularities]]],AddSIng]]],"Candidate singularities found:"]];
Print["Candidate singularities found:",sing];
myEven=Thread[Array[W,Length[#1]]->Log[#1]]&[If[SameQ[AddLetterS,{}],sing,Join[sing,AddLetterS[[1]]]]];
myRoots=Thread[Array[r,Length[#1]]->#1]&[
Select[DeleteDuplicates[
Join[
If[SameQ[ExtraRootS,{}],{},
If[SameQ[ExtraRootS,All]||SameQ[ExtraRootS,{All,All}],
Flatten[Table[Sqrt[sing]*Sqrt[sing[[ii]]],{ii,Length[sing]}]],
If[!SameQ[Length[ExtraRootS],2],Print[Style["DoubleRoots syntax is wrong! It should be of the form: {} or {list1,list2} or {list1,All} or All.",Bold,Red]];Abort[],
If[IntersectingQ[ExtraRootS,{All}],Flatten[Table[Sqrt[sing]*Sqrt[#1[[ii]]],{ii,Length[#1]}]]&[DeleteCases[ExtraRootS/.{}:>{1},All][[1]]],
Flatten[Table[Sqrt[#1[[1]][[i]]]*Sqrt[#1[[2]][[j]]],{i,Length[#1[[1]]]},{j,Length[#1[[2]]]}]&[(ExtraRootS/.{}:>{1})]
]]
]
]
],
Sqrt[sing]]],!FreeQ[#,Sqrt[___]]&]
];
PrintTemporary["List of square roots and rational entries:",myRoots];
Print[myRoots];
If[SameQ[Global`SOFIAoptionFiniteFlow,True],Print["SOFIA is using FiniteFlow. If an error occurs, try changing SOFIAoptionFiniteFlow=False."];,Print["SOFIA is not using FiniteFlow."];];
myOdd00=If[SameQ[Global`SOFIAoptionFiniteFlow,True],
Effortless`RunEffortlessIndependentFF[myRoots[[All,1]],myEven,myRoots,Variables[sing],"DoubleSquareRoots"->True,"Verbose"->False],
Effortless`RunEffortlessIndependent[myRoots[[All,1]],myEven,myRoots,Variables[sing],"DoubleSquareRoots"->True,"Verbose"->False]];
myOdd00=If[SameQ[AddLetterS,{}],myOdd00,Join[myOdd00,AddLetterS[[2]]]];
myOdd=Table[Thread[W[Length[myEven]+ii]->myOdd00[[ii]]],{ii,Length[myOdd00]}];
PrintTemporary["List of even and odd letters:",Join[myEven,myOdd]];
Return[{myEven,myOdd,myRoots}];
]]
],"Total runtime="];
SOFIADecomposeAlphabet[AlphabetToDecompose_,(*Format: myEven_,myOdd_,myRoots_*)SymbolData_]:=SOFIADecomposeAlphabet[AlphabetToDecompose,SymbolData]=Module[{ToVarsTEMP,nVars,vars,myAlpha,ansatz,ansatzabstract,dummynum,solIm,solRe,OUT,ccc},
ToVarsTEMP=Thread[#1->Array[v,Length[#1]]]&[Variables[Join[SymbolData[[3]],SymbolData[[1]]][[All,2]]//.Log[a__]:>a]];
nVars=Length[ToVarsTEMP];
vars=Array[v,nVars];
myAlpha=(Join[SymbolData[[1]][[All,2]],SymbolData[[2]][[All,2]]]/.SymbolData[[3]]/. ToVarsTEMP);
ansatz=Sum[ccc[i] myAlpha[[i]],{i,Length[myAlpha]}];
ansatzabstract=Sum[ccc[i]W[i],{i,Length[myAlpha]}];
Do[
dummynum=Table[Thread[vars->RandomReal[{0,100},Length[vars],WorkingPrecision->170]],{ii,Length[myAlpha]}];
solRe=First[NSolve[Chop[ComplexExpand[Re[DeleteCases[Cases[Collect[d[ansatz-(AlphabetToDecompose[[DOING]]/.SymbolData[[3]]/. ToVarsTEMP)]//.Applyd[vars],d[__]]+dummy,_],dummy]//.d[__]:>1//.dummynum]]]==0,Array[ccc,Length[myAlpha]],WorkingPrecision->(*30*)20]]//.Rule[a_,b_]:>Rule[a,Rationalize[Chop[b]]]/.Rule[a_,b_]:>Rule[a,b//.ccc[___]:>0]//Quiet;
If[SameQ[solRe,{}],Print["The SOFIA alphabet seems not to be able to decompose the alphabet."],If[SameQ[#1,True],PrintTemporary["Decomposed!"],PrintTemporary["The SOFIA alphabet seems not to be able to decompose this letter..."]]&[Chop[Rationalize[Collect[N[d[ansatz-(AlphabetToDecompose[[DOING]]/.SymbolData[[3]]/. ToVarsTEMP)]//.Applyd[vars]//.solRe//.ccc[___]:>0,100],d[___],Factor]]]==0]];
PrintTemporary[OUT[DOING]=If[SameQ[solRe,{}],ImpossibleToDecomposeLetter,Thread[AlphabetToDecompose[[DOING]]->ansatzabstract//.solRe]//.ccc[___]:>0]],{DOING,Length[AlphabetToDecompose]}
];
Return[Flatten[Table[OUT[DOING],{DOING,Length[AlphabetToDecompose]}]]];
];

(*End package:*)
Print["Copyright \[Copyright] 2025 Miguel Correia, Mathieu Giroux, and Sebastian Mizera. All rights reserved."];
If[$Notebooks, 
  Print["Most important documented functions:"];
  Print @ Column[
    {
    "FeynmanDraw: Running this function will trigger a drawing window, allowing you to draw your diagram with your mouse. The output is the corresponding list of edges and nodes for the diagram.",
    "FeynmanPlot: Draws the input diagram.",
    "SOFIABaikov: Returns the optimized LBL Baikov representation for an input diagram (list of edges and nodes).",
    "SOFIA: Returns the singularities or letters depending on options.",
    "SOFIADecomposeAlphabet: SOFIADecomposeAlphabet[LetterToDecompose,SymbolData] - decomposes the letter LetterToDecompose in terms of the alphabet provided in SymbolData.",
    "SolvePolynomialSystem: Solves a polynomial system using the method specified by Solver->{FastFubini, momentumPLD} option.",
    "HistoryGraph: Displays the history of parent and chidren subtopologies."
}, 
    Spacings -> 0.7
  ];
];
End[]
EndPackage[]
